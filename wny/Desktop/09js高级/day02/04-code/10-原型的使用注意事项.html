<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<script>
		//原型的使用注意事项：
			//1. 一般只将需要共享的内容放到原型当中
			//2. 当使用对象去访问一个属性的时候，会先在对象本身进行查找，如果找到了就直接使用，如果找不到，就回去原型中进行查找！

			//3. 当使用对象去设置一个属性的值的时候，只会在对象本身中进行查找，如果对象自己有这个属性，就把这个属性的值进行修改，如果对象自己没有这个属性，就直接为对象新增这个属性，这个过程和原型一点关系都没有

			//4. 在给构造函数的prototype属性重新赋值的时候，重新赋值之前创建的对象能够访问的原型，和重新赋值之后创建的对象能够访问的原型是不一致的！

			//5. 一般情况下，修改原型的操作都几种在一块，也就是在构造函数声明之后，集中对原型做修改，之后，就不会再有修改原型的代码了！
			
		// function Person(){
		// }

		// Person.prototype.name = "张学友";

		// var p = new Person();
		// p.name = "刘德华";
		// console.log(p.name);

		// var str = p.name;


		// var p1 = new Person();
		// console.log(p1.name);


		function Person(){

		}

		//在系统帮我们创建的默认的原型对象中新增了一个sayHello方法
		Person.prototype.sayHello = function(){
			console.log("太阳当空照");
		}

		//创建了一个对象
		var p = new Person();
		//能够访问到sayHello方法，因为原型中有
		p.sayHello();


		//自己创建一个对象，把他作为构造函数的原型
		Person.prototype = {
			sayHi: function(){
				console.log("花儿对我笑");
			}
		};

		//创建一个p1对象，p1对象能够访问的原型，就是我们自己上一步创建的这个对象，里面有sayHi方法
		var p1 = new Person();
		p1.sayHi();

		//因为p1能够访问的原型是我们自己创建的对象，这个对象中并没有sayHello方法
		p1.sayHello();

		//因为p对象能够访问的原型，并没有因为我们将构造函数的原型指向进行了修改而发生变化，p对象能够访问的原型还是原来系统默认创建的那个原型，所以他还是可以使用sayHello，但是不能使用sayHi
		// p.sayHi();
		// p.sayHello();

	</script>
</head>
<body>
	
</body>
</html>